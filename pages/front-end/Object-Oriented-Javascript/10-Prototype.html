<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Javascript</title>

    <link rel="stylesheet" href="../../../styles/front-end-navbar.css" type="text/css">
    <link rel="stylesheet" href="../../../styles/Object-Oriented-Javascript/Object-Oriented-Javascript-Template.css" type="text/css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Raleway:wght@600&family=Roboto+Condensed:wght@400;700&display=swap"
        rel="stylesheet">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
        integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
</head>
<body>
    <main class="main-content">
        <h1>X. Prototype</h1>
        <div class="content-section">
            <p>
                After some investigation, I was able to find out why defining the functions on the constructor function is bad.
                In order to explain why, we need to consolidate some of the Javascript mechanics.
            </p>
            <p>
                First of all, the class is nothing more than a template/blueprint that Javascript will use to create objects.
                For now, let's think of constructor functions as classes.
            </p>
            <p>
                So if classes are just a template then how does every instance now what function logic to call? well, every
                single instance has to make a copy of attributes and functions according to what is defined on the blueprint.                
            </p>
            <p>
                In the case of methods, you may think to yourself that it might be a waste of space to create a new copy for 
                every single instance of the same function that will always have the same functionality. You will be right.
                What we can do for methods is use the prototype object. So what is the prototype object? We can think of it
                as a collection of attributes and methods that every class has that can be accessed by every instance. When
                Javascript creates a new instance, it gives such instance a reference to this prototype object unique to the
                class; and so on for every later created instance.
            </p>
            <p>
                You might as well be wondering, well, how about normal attributes? In that case, we need to remember that
                methods are just attributes that are referencing a piece of functionality that never changes. That's what
                attributes do, they reference something. However, normal attributes are like directions to containers.
                So if every instance is trying to access the same container, you can see how there is a problem if such
                attribute happens to be called 'password'.
            </p>
            <p>
                So in the case of attributes we don't put them on the prototype object. And that's when we realize something
                interesting. This is essentially a textbook example of the flyweight pattern!
            </p>
            <p>
                So, to wrap things up, prototype is used to store either methods or static attributes. This means that if 
                you check the prototype object of any default Javascript Object like 'Array', you will find all the methods
                that such Object has. 
            </p>
            <p class="file-type-style">main.js</p><br><br>
            <div class="code-container">
                <p class="language-feature">
                    function <span class="custom-dev-creation">
                        User(email, name) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;
                            <span class="language-feature">this.</span>email = email;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;
                            <span class="language-feature">this.</span>name = name;<br>
                        }
                    </span>
                </p>
                <p class="comment">// You can only access the prototype via the Constructor function itself</p>
                <p class="language-feature">
                    <span class="custom-dev-creation">User.</span>prototype.<span class="custom-dev-creation">login</span> =
                    function() {<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;
                        console.log(this.<span class="custom-dev-creation">email + " logged in"</span>);<br>
                    }
                </p>
                <br>
                <p class="language-feature">let 
                    <span class="custom-dev-creation">user1 = </span>new
                    <span class="custom-dev-creation">User("john@gmail.com", "John Doe");</span>
                </p>
                <p class="custom-dev-creation">user1.login();</p>
            </div><br>
            <div class="next-chapter-cheater">
                <a class="next-chapter" href="./11-Prototype-Inheritance.html">
                    Next chapter<i class="fa-solid fa-sort-up fa-rotate-90"></i>
                </a>
            </div>
        </div><br><br>
    </main>
    <script src="../../../js/front-end/Object-Oriented-Javascript/10-Prototype.js"></script>
    <!-- NAVBAR COMPONENT -->
    <script src="../../../js/front-end/navbar-component.js"></script>
</body>
</html>